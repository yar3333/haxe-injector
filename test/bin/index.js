// Generated by Haxe 4.3.3
(function ($global) { "use strict";
var $hxClasses = {},$estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
class HxOverrides {
	static cca(s,index) {
		let x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
	static substr(s,pos,len) {
		if(len == null) {
			len = s.length;
		} else if(len < 0) {
			if(pos == 0) {
				len = s.length + len;
			} else {
				return "";
			}
		}
		return s.substr(pos,len);
	}
	static remove(a,obj) {
		let i = a.indexOf(obj);
		if(i == -1) {
			return false;
		}
		a.splice(i,1);
		return true;
	}
	static now() {
		return Date.now();
	}
}
$hxClasses["HxOverrides"] = HxOverrides;
HxOverrides.__name__ = "HxOverrides";
class Lambda {
	static has(it,elt) {
		let x = $getIterator(it);
		while(x.hasNext()) {
			let x1 = x.next();
			if(x1 == elt) {
				return true;
			}
		}
		return false;
	}
	static exists(it,f) {
		let x = $getIterator(it);
		while(x.hasNext()) {
			let x1 = x.next();
			if(f(x1)) {
				return true;
			}
		}
		return false;
	}
}
$hxClasses["Lambda"] = Lambda;
Lambda.__name__ = "Lambda";
class Main {
	static main() {
		let injector = new js_injecting_Injector();
		console.log("test/src/Main.hx:11:","injector.addSingleton(MyService)");
		injector.addSingletonSimple(mypack_MyService);
		console.log("test/src/Main.hx:14:","injector.addSingletonMappedToValue(MyService2, new MyService2(true))");
		injector.addSingletonMappedToValue(mypack_MyService2,new mypack_MyService2(true));
		console.log("test/src/Main.hx:17:","injector.addInstance(MyInstance)");
		injector.addInstanceSimple(mypack_MyInstance);
		console.log("test/src/Main.hx:20:","injector.getService(MyService)");
		let service = injector.getService(mypack_MyService);
		console.log("test/src/Main.hx:22:",service != null ? "`service` defined" : "`service` NOT DEFINED");
	}
}
$hxClasses["Main"] = Main;
Main.__name__ = "Main";
Math.__name__ = "Math";
class Reflect {
	static field(o,field) {
		try {
			return o[field];
		} catch( _g ) {
			return null;
		}
	}
}
$hxClasses["Reflect"] = Reflect;
Reflect.__name__ = "Reflect";
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
	static parseInt(x) {
		let v = parseInt(x);
		if(isNaN(v)) {
			return null;
		}
		return v;
	}
}
$hxClasses["Std"] = Std;
Std.__name__ = "Std";
class StringBuf {
	constructor() {
		this.b = "";
	}
}
$hxClasses["StringBuf"] = StringBuf;
StringBuf.__name__ = "StringBuf";
Object.assign(StringBuf.prototype, {
	__class__: StringBuf
});
class StringTools {
	static htmlEscape(s,quotes) {
		let buf_b = "";
		let _g_offset = 0;
		let _g_s = s;
		while(_g_offset < _g_s.length) {
			let s = _g_s;
			let index = _g_offset++;
			let c = s.charCodeAt(index);
			if(c >= 55296 && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
			}
			let c1 = c;
			if(c1 >= 65536) {
				++_g_offset;
			}
			let code = c1;
			switch(code) {
			case 34:
				if(quotes) {
					buf_b += "&quot;";
				} else {
					buf_b += String.fromCodePoint(code);
				}
				break;
			case 38:
				buf_b += "&amp;";
				break;
			case 39:
				if(quotes) {
					buf_b += "&#039;";
				} else {
					buf_b += String.fromCodePoint(code);
				}
				break;
			case 60:
				buf_b += "&lt;";
				break;
			case 62:
				buf_b += "&gt;";
				break;
			default:
				buf_b += String.fromCodePoint(code);
			}
		}
		return buf_b;
	}
	static isSpace(s,pos) {
		let c = HxOverrides.cca(s,pos);
		if(!(c > 8 && c < 14)) {
			return c == 32;
		} else {
			return true;
		}
	}
	static ltrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,r)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,r,l - r);
		} else {
			return s;
		}
	}
	static rtrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,0,l - r);
		} else {
			return s;
		}
	}
	static trim(s) {
		return StringTools.ltrim(StringTools.rtrim(s));
	}
}
$hxClasses["StringTools"] = StringTools;
StringTools.__name__ = "StringTools";
class Type {
	static createInstance(cl,args) {
		let ctor = Function.prototype.bind.apply(cl,[null].concat(args));
		return new (ctor);
	}
	static getClassFields(c) {
		let a = Object.getOwnPropertyNames(c);
		HxOverrides.remove(a,"__id__");
		HxOverrides.remove(a,"hx__closures__");
		HxOverrides.remove(a,"__name__");
		HxOverrides.remove(a,"__interfaces__");
		HxOverrides.remove(a,"__isInterface__");
		HxOverrides.remove(a,"__properties__");
		HxOverrides.remove(a,"__instanceFields__");
		HxOverrides.remove(a,"__super__");
		HxOverrides.remove(a,"__meta__");
		HxOverrides.remove(a,"prototype");
		HxOverrides.remove(a,"name");
		HxOverrides.remove(a,"length");
		return a;
	}
}
$hxClasses["Type"] = Type;
Type.__name__ = "Type";
class XmlType {
	static toString(this1) {
		switch(this1) {
		case 0:
			return "Element";
		case 1:
			return "PCData";
		case 2:
			return "CData";
		case 3:
			return "Comment";
		case 4:
			return "DocType";
		case 5:
			return "ProcessingInstruction";
		case 6:
			return "Document";
		}
	}
}
class Xml {
	constructor(nodeType) {
		this.nodeType = nodeType;
		this.children = [];
		this.attributeMap = new haxe_ds_StringMap();
	}
	get(att) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return this.attributeMap.h[att];
	}
	set(att,value) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		this.attributeMap.h[att] = value;
	}
	exists(att) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return Object.prototype.hasOwnProperty.call(this.attributeMap.h,att);
	}
	attributes() {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return new haxe_ds__$StringMap_StringMapKeyIterator(this.attributeMap.h);
	}
	elements() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		let _g = [];
		let _g1 = 0;
		let _g2 = this.children;
		while(_g1 < _g2.length) {
			let child = _g2[_g1];
			++_g1;
			if(child.nodeType == Xml.Element) {
				_g.push(child);
			}
		}
		let ret = _g;
		return new haxe_iterators_ArrayIterator(ret);
	}
	elementsNamed(name) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		let _g = [];
		let _g1 = 0;
		let _g2 = this.children;
		while(_g1 < _g2.length) {
			let child = _g2[_g1];
			++_g1;
			let tmp;
			if(child.nodeType == Xml.Element) {
				if(child.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (child.nodeType == null ? "null" : XmlType.toString(child.nodeType)));
				}
				tmp = child.nodeName == name;
			} else {
				tmp = false;
			}
			if(tmp) {
				_g.push(child);
			}
		}
		let ret = _g;
		return new haxe_iterators_ArrayIterator(ret);
	}
	firstElement() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			if(child.nodeType == Xml.Element) {
				return child;
			}
		}
		return null;
	}
	addChild(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		if(x.parent != null) {
			x.parent.removeChild(x);
		}
		this.children.push(x);
		x.parent = this;
	}
	removeChild(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		if(HxOverrides.remove(this.children,x)) {
			x.parent = null;
			return true;
		}
		return false;
	}
	toString() {
		return haxe_xml_Printer.print(this);
	}
	static parse(str) {
		return haxe_xml_Parser.parse(str);
	}
	static createElement(name) {
		let xml = new Xml(Xml.Element);
		if(xml.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		xml.nodeName = name;
		return xml;
	}
	static createPCData(data) {
		let xml = new Xml(Xml.PCData);
		if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		xml.nodeValue = data;
		return xml;
	}
	static createCData(data) {
		let xml = new Xml(Xml.CData);
		if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		xml.nodeValue = data;
		return xml;
	}
	static createComment(data) {
		let xml = new Xml(Xml.Comment);
		if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		xml.nodeValue = data;
		return xml;
	}
	static createDocType(data) {
		let xml = new Xml(Xml.DocType);
		if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		xml.nodeValue = data;
		return xml;
	}
	static createProcessingInstruction(data) {
		let xml = new Xml(Xml.ProcessingInstruction);
		if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		xml.nodeValue = data;
		return xml;
	}
	static createDocument() {
		return new Xml(Xml.Document);
	}
}
$hxClasses["Xml"] = Xml;
Xml.__name__ = "Xml";
Object.assign(Xml.prototype, {
	__class__: Xml
});
class haxe_IMap {
}
$hxClasses["haxe.IMap"] = haxe_IMap;
haxe_IMap.__name__ = "haxe.IMap";
class haxe_Exception extends Error {
	constructor(message,previous,native) {
		super(message);
		this.message = message;
		this.__previousException = previous;
		this.__nativeException = native != null ? native : this;
	}
	get_native() {
		return this.__nativeException;
	}
	static thrown(value) {
		if(((value) instanceof haxe_Exception)) {
			return value.get_native();
		} else if(((value) instanceof Error)) {
			return value;
		} else {
			let e = new haxe_ValueException(value);
			return e;
		}
	}
}
$hxClasses["haxe.Exception"] = haxe_Exception;
haxe_Exception.__name__ = "haxe.Exception";
haxe_Exception.__super__ = Error;
Object.assign(haxe_Exception.prototype, {
	__class__: haxe_Exception
});
class haxe_ValueException extends haxe_Exception {
	constructor(value,previous,native) {
		super(String(value),previous,native);
		this.value = value;
	}
}
$hxClasses["haxe.ValueException"] = haxe_ValueException;
haxe_ValueException.__name__ = "haxe.ValueException";
haxe_ValueException.__super__ = haxe_Exception;
Object.assign(haxe_ValueException.prototype, {
	__class__: haxe_ValueException
});
class haxe_ds_StringMap {
	constructor() {
		this.h = Object.create(null);
	}
}
$hxClasses["haxe.ds.StringMap"] = haxe_ds_StringMap;
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
Object.assign(haxe_ds_StringMap.prototype, {
	__class__: haxe_ds_StringMap
});
class haxe_ds__$StringMap_StringMapKeyIterator {
	constructor(h) {
		this.h = h;
		this.keys = Object.keys(h);
		this.length = this.keys.length;
		this.current = 0;
	}
	hasNext() {
		return this.current < this.length;
	}
	next() {
		return this.keys[this.current++];
	}
}
$hxClasses["haxe.ds._StringMap.StringMapKeyIterator"] = haxe_ds__$StringMap_StringMapKeyIterator;
haxe_ds__$StringMap_StringMapKeyIterator.__name__ = "haxe.ds._StringMap.StringMapKeyIterator";
Object.assign(haxe_ds__$StringMap_StringMapKeyIterator.prototype, {
	__class__: haxe_ds__$StringMap_StringMapKeyIterator
});
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
$hxClasses["haxe.iterators.ArrayIterator"] = haxe_iterators_ArrayIterator;
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
Object.assign(haxe_iterators_ArrayIterator.prototype, {
	__class__: haxe_iterators_ArrayIterator
});
var haxe_rtti_CType = $hxEnums["haxe.rtti.CType"] = { __ename__:true,__constructs__:null
	,CUnknown: {_hx_name:"CUnknown",_hx_index:0,__enum__:"haxe.rtti.CType",toString:$estr}
	,CEnum: ($_=function(name,params) { return {_hx_index:1,name:name,params:params,__enum__:"haxe.rtti.CType",toString:$estr}; },$_._hx_name="CEnum",$_.__params__ = ["name","params"],$_)
	,CClass: ($_=function(name,params) { return {_hx_index:2,name:name,params:params,__enum__:"haxe.rtti.CType",toString:$estr}; },$_._hx_name="CClass",$_.__params__ = ["name","params"],$_)
	,CTypedef: ($_=function(name,params) { return {_hx_index:3,name:name,params:params,__enum__:"haxe.rtti.CType",toString:$estr}; },$_._hx_name="CTypedef",$_.__params__ = ["name","params"],$_)
	,CFunction: ($_=function(args,ret) { return {_hx_index:4,args:args,ret:ret,__enum__:"haxe.rtti.CType",toString:$estr}; },$_._hx_name="CFunction",$_.__params__ = ["args","ret"],$_)
	,CAnonymous: ($_=function(fields) { return {_hx_index:5,fields:fields,__enum__:"haxe.rtti.CType",toString:$estr}; },$_._hx_name="CAnonymous",$_.__params__ = ["fields"],$_)
	,CDynamic: ($_=function(t) { return {_hx_index:6,t:t,__enum__:"haxe.rtti.CType",toString:$estr}; },$_._hx_name="CDynamic",$_.__params__ = ["t"],$_)
	,CAbstract: ($_=function(name,params) { return {_hx_index:7,name:name,params:params,__enum__:"haxe.rtti.CType",toString:$estr}; },$_._hx_name="CAbstract",$_.__params__ = ["name","params"],$_)
};
haxe_rtti_CType.__constructs__ = [haxe_rtti_CType.CUnknown,haxe_rtti_CType.CEnum,haxe_rtti_CType.CClass,haxe_rtti_CType.CTypedef,haxe_rtti_CType.CFunction,haxe_rtti_CType.CAnonymous,haxe_rtti_CType.CDynamic,haxe_rtti_CType.CAbstract];
var haxe_rtti_Rights = $hxEnums["haxe.rtti.Rights"] = { __ename__:true,__constructs__:null
	,RNormal: {_hx_name:"RNormal",_hx_index:0,__enum__:"haxe.rtti.Rights",toString:$estr}
	,RNo: {_hx_name:"RNo",_hx_index:1,__enum__:"haxe.rtti.Rights",toString:$estr}
	,RCall: ($_=function(m) { return {_hx_index:2,m:m,__enum__:"haxe.rtti.Rights",toString:$estr}; },$_._hx_name="RCall",$_.__params__ = ["m"],$_)
	,RMethod: {_hx_name:"RMethod",_hx_index:3,__enum__:"haxe.rtti.Rights",toString:$estr}
	,RDynamic: {_hx_name:"RDynamic",_hx_index:4,__enum__:"haxe.rtti.Rights",toString:$estr}
	,RInline: {_hx_name:"RInline",_hx_index:5,__enum__:"haxe.rtti.Rights",toString:$estr}
};
haxe_rtti_Rights.__constructs__ = [haxe_rtti_Rights.RNormal,haxe_rtti_Rights.RNo,haxe_rtti_Rights.RCall,haxe_rtti_Rights.RMethod,haxe_rtti_Rights.RDynamic,haxe_rtti_Rights.RInline];
var haxe_rtti_TypeTree = $hxEnums["haxe.rtti.TypeTree"] = { __ename__:true,__constructs__:null
	,TPackage: ($_=function(name,full,subs) { return {_hx_index:0,name:name,full:full,subs:subs,__enum__:"haxe.rtti.TypeTree",toString:$estr}; },$_._hx_name="TPackage",$_.__params__ = ["name","full","subs"],$_)
	,TClassdecl: ($_=function(c) { return {_hx_index:1,c:c,__enum__:"haxe.rtti.TypeTree",toString:$estr}; },$_._hx_name="TClassdecl",$_.__params__ = ["c"],$_)
	,TEnumdecl: ($_=function(e) { return {_hx_index:2,e:e,__enum__:"haxe.rtti.TypeTree",toString:$estr}; },$_._hx_name="TEnumdecl",$_.__params__ = ["e"],$_)
	,TTypedecl: ($_=function(t) { return {_hx_index:3,t:t,__enum__:"haxe.rtti.TypeTree",toString:$estr}; },$_._hx_name="TTypedecl",$_.__params__ = ["t"],$_)
	,TAbstractdecl: ($_=function(a) { return {_hx_index:4,a:a,__enum__:"haxe.rtti.TypeTree",toString:$estr}; },$_._hx_name="TAbstractdecl",$_.__params__ = ["a"],$_)
};
haxe_rtti_TypeTree.__constructs__ = [haxe_rtti_TypeTree.TPackage,haxe_rtti_TypeTree.TClassdecl,haxe_rtti_TypeTree.TEnumdecl,haxe_rtti_TypeTree.TTypedecl,haxe_rtti_TypeTree.TAbstractdecl];
class haxe_rtti_Rtti {
	static getRtti(c) {
		let rtti = Reflect.field(c,"__rtti");
		if(rtti == null) {
			throw haxe_Exception.thrown("Class " + c.__name__ + " has no RTTI information, consider adding @:rtti");
		}
		let x = Xml.parse(rtti).firstElement();
		let infos = new haxe_rtti_XmlParser().processElement(x);
		if(infos._hx_index == 1) {
			let c = infos.c;
			return c;
		} else {
			let t = infos;
			throw haxe_Exception.thrown("Enum mismatch: expected TClassDecl but found " + Std.string(t));
		}
	}
	static hasRtti(c) {
		return Lambda.has(Type.getClassFields(c),"__rtti");
	}
}
$hxClasses["haxe.rtti.Rtti"] = haxe_rtti_Rtti;
haxe_rtti_Rtti.__name__ = "haxe.rtti.Rtti";
class haxe_rtti_XmlParser {
	constructor() {
		this.root = [];
	}
	mkPath(p) {
		return p;
	}
	mkTypeParams(p) {
		let pl = p.split(":");
		if(pl[0] == "") {
			return [];
		}
		return pl;
	}
	mkRights(r) {
		switch(r) {
		case "dynamic":
			return haxe_rtti_Rights.RDynamic;
		case "inline":
			return haxe_rtti_Rights.RInline;
		case "method":
			return haxe_rtti_Rights.RMethod;
		case "null":
			return haxe_rtti_Rights.RNo;
		default:
			return haxe_rtti_Rights.RCall(r);
		}
	}
	xerror(c) {
		let tmp;
		if(c.nodeType == Xml.Document) {
			tmp = "Document";
		} else {
			if(c.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (c.nodeType == null ? "null" : XmlType.toString(c.nodeType)));
			}
			tmp = c.nodeName;
		}
		throw haxe_Exception.thrown("Invalid " + tmp);
	}
	processElement(x) {
		if(x.nodeType != Xml.Document && x.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Invalid nodeType " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
		}
		let c = x;
		let _g;
		if(c.nodeType == Xml.Document) {
			_g = "Document";
		} else {
			if(c.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (c.nodeType == null ? "null" : XmlType.toString(c.nodeType)));
			}
			_g = c.nodeName;
		}
		switch(_g) {
		case "abstract":
			return haxe_rtti_TypeTree.TAbstractdecl(this.xabstract(c));
		case "class":
			return haxe_rtti_TypeTree.TClassdecl(this.xclass(c));
		case "enum":
			return haxe_rtti_TypeTree.TEnumdecl(this.xenum(c));
		case "typedef":
			return haxe_rtti_TypeTree.TTypedecl(this.xtypedef(c));
		default:
			return this.xerror(c);
		}
	}
	xmeta(x) {
		let ml = [];
		let _g = 0;
		let _g1 = haxe_xml__$Access_NodeListAccess.resolve(x,"m");
		while(_g < _g1.length) {
			let m = _g1[_g];
			++_g;
			let pl = [];
			let _g2 = 0;
			let _g3 = haxe_xml__$Access_NodeListAccess.resolve(m,"e");
			while(_g2 < _g3.length) {
				let p = _g3[_g2];
				++_g2;
				pl.push(haxe_xml_Access.get_innerHTML(p));
			}
			ml.push({ name : haxe_xml__$Access_AttribAccess.resolve(m,"n"), params : pl});
		}
		return ml;
	}
	xoverloads(x) {
		let l = [];
		let m = x.elements();
		while(m.hasNext()) {
			let m1 = m.next();
			l.push(this.xclassfield(m1));
		}
		return l;
	}
	xpath(x) {
		let path = this.mkPath(haxe_xml__$Access_AttribAccess.resolve(x,"path"));
		let params = [];
		let c = x.elements();
		while(c.hasNext()) {
			let c1 = c.next();
			params.push(this.xtype(c1));
		}
		return { path : path, params : params};
	}
	xclass(x) {
		let csuper = null;
		let doc = null;
		let tdynamic = null;
		let interfaces = [];
		let fields = [];
		let statics = [];
		let meta = [];
		let isInterface = x.exists("interface");
		let c = x.elements();
		while(c.hasNext()) {
			let c1 = c.next();
			let _g;
			if(c1.nodeType == Xml.Document) {
				_g = "Document";
			} else {
				if(c1.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (c1.nodeType == null ? "null" : XmlType.toString(c1.nodeType)));
				}
				_g = c1.nodeName;
			}
			switch(_g) {
			case "extends":
				if(isInterface) {
					interfaces.push(this.xpath(c1));
				} else {
					csuper = this.xpath(c1);
				}
				break;
			case "haxe_doc":
				doc = haxe_xml_Access.get_innerData(c1);
				break;
			case "haxe_dynamic":
				let x = c1.firstElement();
				if(x.nodeType != Xml.Document && x.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Invalid nodeType " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
				}
				tdynamic = this.xtype(x);
				break;
			case "implements":
				interfaces.push(this.xpath(c1));
				break;
			case "meta":
				meta = this.xmeta(c1);
				break;
			default:
				if(c1.exists("static")) {
					statics.push(this.xclassfield(c1));
				} else {
					fields.push(this.xclassfield(c1));
				}
			}
		}
		return { file : haxe_xml__$Access_HasAttribAccess.resolve(x,"file") ? haxe_xml__$Access_AttribAccess.resolve(x,"file") : null, path : this.mkPath(haxe_xml__$Access_AttribAccess.resolve(x,"path")), module : haxe_xml__$Access_HasAttribAccess.resolve(x,"module") ? this.mkPath(haxe_xml__$Access_AttribAccess.resolve(x,"module")) : null, doc : doc, isPrivate : x.exists("private"), isExtern : x.exists("extern"), isFinal : x.exists("final"), isInterface : isInterface, params : this.mkTypeParams(haxe_xml__$Access_AttribAccess.resolve(x,"params")), superClass : csuper, interfaces : interfaces, fields : fields, statics : statics, tdynamic : tdynamic, platforms : this.defplat(), meta : meta};
	}
	xclassfield(x,defPublic) {
		if(defPublic == null) {
			defPublic = false;
		}
		let e = x.elements();
		let t = this.xtype(e.next());
		let doc = null;
		let meta = [];
		let overloads = null;
		let c = e;
		while(c.hasNext()) {
			let c1 = c.next();
			let _g;
			if(c1.nodeType == Xml.Document) {
				_g = "Document";
			} else {
				if(c1.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (c1.nodeType == null ? "null" : XmlType.toString(c1.nodeType)));
				}
				_g = c1.nodeName;
			}
			switch(_g) {
			case "haxe_doc":
				doc = haxe_xml_Access.get_innerData(c1);
				break;
			case "meta":
				meta = this.xmeta(c1);
				break;
			case "overloads":
				overloads = this.xoverloads(c1);
				break;
			default:
				this.xerror(c1);
			}
		}
		let tmp;
		if(x.nodeType == Xml.Document) {
			tmp = "Document";
		} else {
			if(x.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
			}
			tmp = x.nodeName;
		}
		return { name : tmp, type : t, isPublic : x.exists("public") || defPublic, isFinal : x.exists("final"), isOverride : x.exists("override"), line : haxe_xml__$Access_HasAttribAccess.resolve(x,"line") ? Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(x,"line")) : null, doc : doc, get : haxe_xml__$Access_HasAttribAccess.resolve(x,"get") ? this.mkRights(haxe_xml__$Access_AttribAccess.resolve(x,"get")) : haxe_rtti_Rights.RNormal, set : haxe_xml__$Access_HasAttribAccess.resolve(x,"set") ? this.mkRights(haxe_xml__$Access_AttribAccess.resolve(x,"set")) : haxe_rtti_Rights.RNormal, params : haxe_xml__$Access_HasAttribAccess.resolve(x,"params") ? this.mkTypeParams(haxe_xml__$Access_AttribAccess.resolve(x,"params")) : [], platforms : this.defplat(), meta : meta, overloads : overloads, expr : haxe_xml__$Access_HasAttribAccess.resolve(x,"expr") ? haxe_xml__$Access_AttribAccess.resolve(x,"expr") : null};
	}
	xenum(x) {
		let cl = [];
		let doc = null;
		let meta = [];
		let c = x.elements();
		while(c.hasNext()) {
			let c1 = c.next();
			let tmp;
			if(c1.nodeType == Xml.Document) {
				tmp = "Document";
			} else {
				if(c1.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (c1.nodeType == null ? "null" : XmlType.toString(c1.nodeType)));
				}
				tmp = c1.nodeName;
			}
			if(tmp == "haxe_doc") {
				doc = haxe_xml_Access.get_innerData(c1);
			} else {
				let tmp;
				if(c1.nodeType == Xml.Document) {
					tmp = "Document";
				} else {
					if(c1.nodeType != Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, expected Element but found " + (c1.nodeType == null ? "null" : XmlType.toString(c1.nodeType)));
					}
					tmp = c1.nodeName;
				}
				if(tmp == "meta") {
					meta = this.xmeta(c1);
				} else {
					cl.push(this.xenumfield(c1));
				}
			}
		}
		return { file : haxe_xml__$Access_HasAttribAccess.resolve(x,"file") ? haxe_xml__$Access_AttribAccess.resolve(x,"file") : null, path : this.mkPath(haxe_xml__$Access_AttribAccess.resolve(x,"path")), module : haxe_xml__$Access_HasAttribAccess.resolve(x,"module") ? this.mkPath(haxe_xml__$Access_AttribAccess.resolve(x,"module")) : null, doc : doc, isPrivate : x.exists("private"), isExtern : x.exists("extern"), params : this.mkTypeParams(haxe_xml__$Access_AttribAccess.resolve(x,"params")), constructors : cl, platforms : this.defplat(), meta : meta};
	}
	xenumfield(x) {
		let args = null;
		let docElements = x.elementsNamed("haxe_doc");
		let xdoc = docElements.hasNext() ? docElements.next() : null;
		let meta = haxe_xml__$Access_HasNodeAccess.resolve(x,"meta") ? this.xmeta(haxe_xml__$Access_NodeAccess.resolve(x,"meta")) : [];
		if(haxe_xml__$Access_HasAttribAccess.resolve(x,"a")) {
			let names = haxe_xml__$Access_AttribAccess.resolve(x,"a").split(":");
			let elts = x.elements();
			args = [];
			let _g = 0;
			while(_g < names.length) {
				let c = names[_g];
				++_g;
				let opt = false;
				if(c.charAt(0) == "?") {
					opt = true;
					c = HxOverrides.substr(c,1,null);
				}
				args.push({ name : c, opt : opt, t : this.xtype(elts.next())});
			}
		}
		let tmp;
		if(x.nodeType == Xml.Document) {
			tmp = "Document";
		} else {
			if(x.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
			}
			tmp = x.nodeName;
		}
		let tmp1;
		if(xdoc == null) {
			tmp1 = null;
		} else {
			if(xdoc.nodeType != Xml.Document && xdoc.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Invalid nodeType " + (xdoc.nodeType == null ? "null" : XmlType.toString(xdoc.nodeType)));
			}
			tmp1 = haxe_xml_Access.get_innerData(xdoc);
		}
		return { name : tmp, args : args, doc : tmp1, meta : meta, platforms : this.defplat()};
	}
	xabstract(x) {
		let doc = null;
		let impl = null;
		let athis = null;
		let meta = [];
		let to = [];
		let from = [];
		let c = x.elements();
		while(c.hasNext()) {
			let c1 = c.next();
			let _g;
			if(c1.nodeType == Xml.Document) {
				_g = "Document";
			} else {
				if(c1.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (c1.nodeType == null ? "null" : XmlType.toString(c1.nodeType)));
				}
				_g = c1.nodeName;
			}
			switch(_g) {
			case "from":
				let t = c1.elements();
				while(t.hasNext()) {
					let t1 = t.next();
					let x = t1.firstElement();
					if(x.nodeType != Xml.Document && x.nodeType != Xml.Element) {
						throw haxe_Exception.thrown("Invalid nodeType " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
					}
					from.push({ t : this.xtype(x), field : haxe_xml__$Access_HasAttribAccess.resolve(t1,"field") ? haxe_xml__$Access_AttribAccess.resolve(t1,"field") : null});
				}
				break;
			case "haxe_doc":
				doc = haxe_xml_Access.get_innerData(c1);
				break;
			case "impl":
				impl = this.xclass(haxe_xml__$Access_NodeAccess.resolve(c1,"class"));
				break;
			case "meta":
				meta = this.xmeta(c1);
				break;
			case "this":
				let x = c1.firstElement();
				if(x.nodeType != Xml.Document && x.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Invalid nodeType " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
				}
				athis = this.xtype(x);
				break;
			case "to":
				let t1 = c1.elements();
				while(t1.hasNext()) {
					let t = t1.next();
					let x = t.firstElement();
					if(x.nodeType != Xml.Document && x.nodeType != Xml.Element) {
						throw haxe_Exception.thrown("Invalid nodeType " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
					}
					to.push({ t : this.xtype(x), field : haxe_xml__$Access_HasAttribAccess.resolve(t,"field") ? haxe_xml__$Access_AttribAccess.resolve(t,"field") : null});
				}
				break;
			default:
				this.xerror(c1);
			}
		}
		return { file : haxe_xml__$Access_HasAttribAccess.resolve(x,"file") ? haxe_xml__$Access_AttribAccess.resolve(x,"file") : null, path : this.mkPath(haxe_xml__$Access_AttribAccess.resolve(x,"path")), module : haxe_xml__$Access_HasAttribAccess.resolve(x,"module") ? this.mkPath(haxe_xml__$Access_AttribAccess.resolve(x,"module")) : null, doc : doc, isPrivate : x.exists("private"), params : this.mkTypeParams(haxe_xml__$Access_AttribAccess.resolve(x,"params")), platforms : this.defplat(), meta : meta, athis : athis, to : to, from : from, impl : impl};
	}
	xtypedef(x) {
		let doc = null;
		let t = null;
		let meta = [];
		let c = x.elements();
		while(c.hasNext()) {
			let c1 = c.next();
			let tmp;
			if(c1.nodeType == Xml.Document) {
				tmp = "Document";
			} else {
				if(c1.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (c1.nodeType == null ? "null" : XmlType.toString(c1.nodeType)));
				}
				tmp = c1.nodeName;
			}
			if(tmp == "haxe_doc") {
				doc = haxe_xml_Access.get_innerData(c1);
			} else {
				let tmp;
				if(c1.nodeType == Xml.Document) {
					tmp = "Document";
				} else {
					if(c1.nodeType != Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, expected Element but found " + (c1.nodeType == null ? "null" : XmlType.toString(c1.nodeType)));
					}
					tmp = c1.nodeName;
				}
				if(tmp == "meta") {
					meta = this.xmeta(c1);
				} else {
					t = this.xtype(c1);
				}
			}
		}
		let types = new haxe_ds_StringMap();
		if(this.curplatform != null) {
			types.h[this.curplatform] = t;
		}
		return { file : haxe_xml__$Access_HasAttribAccess.resolve(x,"file") ? haxe_xml__$Access_AttribAccess.resolve(x,"file") : null, path : this.mkPath(haxe_xml__$Access_AttribAccess.resolve(x,"path")), module : haxe_xml__$Access_HasAttribAccess.resolve(x,"module") ? this.mkPath(haxe_xml__$Access_AttribAccess.resolve(x,"module")) : null, doc : doc, isPrivate : x.exists("private"), params : this.mkTypeParams(haxe_xml__$Access_AttribAccess.resolve(x,"params")), type : t, types : types, platforms : this.defplat(), meta : meta};
	}
	xtype(x) {
		let _g;
		if(x.nodeType == Xml.Document) {
			_g = "Document";
		} else {
			if(x.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
			}
			_g = x.nodeName;
		}
		switch(_g) {
		case "a":
			let fields = [];
			let f = x.elements();
			while(f.hasNext()) {
				let f1 = f.next();
				let f2 = this.xclassfield(f1,true);
				f2.platforms = [];
				fields.push(f2);
			}
			return haxe_rtti_CType.CAnonymous(fields);
		case "c":
			return haxe_rtti_CType.CClass(this.mkPath(haxe_xml__$Access_AttribAccess.resolve(x,"path")),this.xtypeparams(x));
		case "d":
			let t = null;
			let tx = x.firstElement();
			if(tx != null) {
				if(tx.nodeType != Xml.Document && tx.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Invalid nodeType " + (tx.nodeType == null ? "null" : XmlType.toString(tx.nodeType)));
				}
				t = this.xtype(tx);
			}
			return haxe_rtti_CType.CDynamic(t);
		case "e":
			return haxe_rtti_CType.CEnum(this.mkPath(haxe_xml__$Access_AttribAccess.resolve(x,"path")),this.xtypeparams(x));
		case "f":
			let args = [];
			let aname = haxe_xml__$Access_AttribAccess.resolve(x,"a").split(":");
			let eargs_current = 0;
			let eargs_array = aname;
			let evalues = haxe_xml__$Access_HasAttribAccess.resolve(x,"v") ? new haxe_iterators_ArrayIterator(haxe_xml__$Access_AttribAccess.resolve(x,"v").split(":")) : null;
			let e = x.elements();
			while(e.hasNext()) {
				let e1 = e.next();
				let opt = false;
				let a = eargs_current < eargs_array.length ? eargs_array[eargs_current++] : null;
				if(a == null) {
					a = "";
				}
				if(a.charAt(0) == "?") {
					opt = true;
					a = HxOverrides.substr(a,1,null);
				}
				let v = evalues == null || evalues.current >= evalues.array.length ? null : evalues.array[evalues.current++];
				args.push({ name : a, opt : opt, t : this.xtype(e1), value : v == "" ? null : v});
			}
			let ret = args[args.length - 1];
			HxOverrides.remove(args,ret);
			return haxe_rtti_CType.CFunction(args,ret.t);
		case "t":
			return haxe_rtti_CType.CTypedef(this.mkPath(haxe_xml__$Access_AttribAccess.resolve(x,"path")),this.xtypeparams(x));
		case "unknown":
			return haxe_rtti_CType.CUnknown;
		case "x":
			return haxe_rtti_CType.CAbstract(this.mkPath(haxe_xml__$Access_AttribAccess.resolve(x,"path")),this.xtypeparams(x));
		default:
			return this.xerror(x);
		}
	}
	xtypeparams(x) {
		let p = [];
		let c = x.elements();
		while(c.hasNext()) {
			let c1 = c.next();
			p.push(this.xtype(c1));
		}
		return p;
	}
	defplat() {
		let l = [];
		if(this.curplatform != null) {
			l.push(this.curplatform);
		}
		return l;
	}
}
$hxClasses["haxe.rtti.XmlParser"] = haxe_rtti_XmlParser;
haxe_rtti_XmlParser.__name__ = "haxe.rtti.XmlParser";
Object.assign(haxe_rtti_XmlParser.prototype, {
	__class__: haxe_rtti_XmlParser
});
class haxe_xml__$Access_NodeAccess {
	static resolve(this1,name) {
		let x = this1.elementsNamed(name).next();
		if(x == null) {
			let xname;
			if(this1.nodeType == Xml.Document) {
				xname = "Document";
			} else {
				if(this1.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this1.nodeType == null ? "null" : XmlType.toString(this1.nodeType)));
				}
				xname = this1.nodeName;
			}
			throw haxe_Exception.thrown(xname + " is missing element " + name);
		}
		if(x.nodeType != Xml.Document && x.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Invalid nodeType " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
		}
		return x;
	}
}
class haxe_xml__$Access_AttribAccess {
	static resolve(this1,name) {
		if(this1.nodeType == Xml.Document) {
			throw haxe_Exception.thrown("Cannot access document attribute " + name);
		}
		let v = this1.get(name);
		if(v == null) {
			if(this1.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this1.nodeType == null ? "null" : XmlType.toString(this1.nodeType)));
			}
			throw haxe_Exception.thrown(this1.nodeName + " is missing attribute " + name);
		}
		return v;
	}
}
class haxe_xml__$Access_HasAttribAccess {
	static resolve(this1,name) {
		if(this1.nodeType == Xml.Document) {
			throw haxe_Exception.thrown("Cannot access document attribute " + name);
		}
		return this1.exists(name);
	}
}
class haxe_xml__$Access_HasNodeAccess {
	static resolve(this1,name) {
		return this1.elementsNamed(name).hasNext();
	}
}
class haxe_xml__$Access_NodeListAccess {
	static resolve(this1,name) {
		let l = [];
		let x = this1.elementsNamed(name);
		while(x.hasNext()) {
			let x1 = x.next();
			if(x1.nodeType != Xml.Document && x1.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Invalid nodeType " + (x1.nodeType == null ? "null" : XmlType.toString(x1.nodeType)));
			}
			l.push(x1);
		}
		return l;
	}
}
class haxe_xml_Access {
	static get_innerData(this1) {
		if(this1.nodeType != Xml.Document && this1.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this1.nodeType == null ? "null" : XmlType.toString(this1.nodeType)));
		}
		let it_current = 0;
		let it_array = this1.children;
		if(it_current >= it_array.length) {
			let tmp;
			if(this1.nodeType == Xml.Document) {
				tmp = "Document";
			} else {
				if(this1.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this1.nodeType == null ? "null" : XmlType.toString(this1.nodeType)));
				}
				tmp = this1.nodeName;
			}
			throw haxe_Exception.thrown(tmp + " does not have data");
		}
		let v = it_array[it_current++];
		if(it_current < it_array.length) {
			let n = it_array[it_current++];
			let tmp;
			if(v.nodeType == Xml.PCData && n.nodeType == Xml.CData) {
				if(v.nodeType == Xml.Document || v.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (v.nodeType == null ? "null" : XmlType.toString(v.nodeType)));
				}
				tmp = StringTools.trim(v.nodeValue) == "";
			} else {
				tmp = false;
			}
			if(tmp) {
				if(it_current >= it_array.length) {
					if(n.nodeType == Xml.Document || n.nodeType == Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, unexpected " + (n.nodeType == null ? "null" : XmlType.toString(n.nodeType)));
					}
					return n.nodeValue;
				}
				let n2 = it_array[it_current++];
				let tmp;
				if(n2.nodeType == Xml.PCData) {
					if(n2.nodeType == Xml.Document || n2.nodeType == Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, unexpected " + (n2.nodeType == null ? "null" : XmlType.toString(n2.nodeType)));
					}
					tmp = StringTools.trim(n2.nodeValue) == "";
				} else {
					tmp = false;
				}
				if(tmp && it_current >= it_array.length) {
					if(n.nodeType == Xml.Document || n.nodeType == Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, unexpected " + (n.nodeType == null ? "null" : XmlType.toString(n.nodeType)));
					}
					return n.nodeValue;
				}
			}
			let tmp1;
			if(this1.nodeType == Xml.Document) {
				tmp1 = "Document";
			} else {
				if(this1.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this1.nodeType == null ? "null" : XmlType.toString(this1.nodeType)));
				}
				tmp1 = this1.nodeName;
			}
			throw haxe_Exception.thrown(tmp1 + " does not only have data");
		}
		if(v.nodeType != Xml.PCData && v.nodeType != Xml.CData) {
			let tmp;
			if(this1.nodeType == Xml.Document) {
				tmp = "Document";
			} else {
				if(this1.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this1.nodeType == null ? "null" : XmlType.toString(this1.nodeType)));
				}
				tmp = this1.nodeName;
			}
			throw haxe_Exception.thrown(tmp + " does not have data");
		}
		if(v.nodeType == Xml.Document || v.nodeType == Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, unexpected " + (v.nodeType == null ? "null" : XmlType.toString(v.nodeType)));
		}
		return v.nodeValue;
	}
	static get_innerHTML(this1) {
		let s_b = "";
		if(this1.nodeType != Xml.Document && this1.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this1.nodeType == null ? "null" : XmlType.toString(this1.nodeType)));
		}
		let _g_current = 0;
		let _g_array = this1.children;
		while(_g_current < _g_array.length) {
			let x = _g_array[_g_current++];
			s_b += Std.string(haxe_xml_Printer.print(x));
		}
		return s_b;
	}
}
class haxe_xml_XmlParserException {
	constructor(message,xml,position) {
		this.xml = xml;
		this.message = message;
		this.position = position;
		this.lineNumber = 1;
		this.positionAtLine = 0;
		let _g = 0;
		let _g1 = position;
		while(_g < _g1) {
			let i = _g++;
			let c = xml.charCodeAt(i);
			if(c == 10) {
				this.lineNumber++;
				this.positionAtLine = 0;
			} else if(c != 13) {
				this.positionAtLine++;
			}
		}
	}
	toString() {
		let c = js_Boot.getClass(this);
		return c.__name__ + ": " + this.message + " at line " + this.lineNumber + " char " + this.positionAtLine;
	}
}
$hxClasses["haxe.xml.XmlParserException"] = haxe_xml_XmlParserException;
haxe_xml_XmlParserException.__name__ = "haxe.xml.XmlParserException";
Object.assign(haxe_xml_XmlParserException.prototype, {
	__class__: haxe_xml_XmlParserException
});
class haxe_xml_Parser {
	static parse(str,strict) {
		if(strict == null) {
			strict = false;
		}
		let doc = Xml.createDocument();
		haxe_xml_Parser.doParse(str,strict,0,doc);
		return doc;
	}
	static doParse(str,strict,p,parent) {
		if(p == null) {
			p = 0;
		}
		let xml = null;
		let state = 1;
		let next = 1;
		let aname = null;
		let start = 0;
		let nsubs = 0;
		let nbrackets = 0;
		let buf = new StringBuf();
		let escapeNext = 1;
		let attrValQuote = -1;
		while(p < str.length) {
			let c = str.charCodeAt(p);
			switch(state) {
			case 0:
				switch(c) {
				case 9:case 10:case 13:case 32:
					break;
				default:
					state = next;
					continue;
				}
				break;
			case 1:
				if(c == 60) {
					state = 0;
					next = 2;
				} else {
					start = p;
					state = 13;
					continue;
				}
				break;
			case 2:
				switch(c) {
				case 33:
					if(str.charCodeAt(p + 1) == 91) {
						p += 2;
						if(HxOverrides.substr(str,p,6).toUpperCase() != "CDATA[") {
							throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <![CDATA[",str,p));
						}
						p += 5;
						state = 17;
						start = p + 1;
					} else if(str.charCodeAt(p + 1) == 68 || str.charCodeAt(p + 1) == 100) {
						if(HxOverrides.substr(str,p + 2,6).toUpperCase() != "OCTYPE") {
							throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <!DOCTYPE",str,p));
						}
						p += 8;
						state = 16;
						start = p + 1;
					} else if(str.charCodeAt(p + 1) != 45 || str.charCodeAt(p + 2) != 45) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <!--",str,p));
					} else {
						p += 2;
						state = 15;
						start = p + 1;
					}
					break;
				case 47:
					if(parent == null) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
					}
					start = p + 1;
					state = 0;
					next = 10;
					break;
				case 63:
					state = 14;
					start = p;
					break;
				default:
					state = 3;
					start = p;
					continue;
				}
				break;
			case 3:
				if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
					if(p == start) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
					}
					xml = Xml.createElement(HxOverrides.substr(str,start,p - start));
					parent.addChild(xml);
					++nsubs;
					state = 0;
					next = 4;
					continue;
				}
				break;
			case 4:
				switch(c) {
				case 47:
					state = 11;
					break;
				case 62:
					state = 9;
					break;
				default:
					state = 5;
					start = p;
					continue;
				}
				break;
			case 5:
				if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
					if(start == p) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected attribute name",str,p));
					}
					let tmp = HxOverrides.substr(str,start,p - start);
					aname = tmp;
					if(xml.exists(aname)) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Duplicate attribute [" + aname + "]",str,p));
					}
					state = 0;
					next = 6;
					continue;
				}
				break;
			case 6:
				if(c == 61) {
					state = 0;
					next = 7;
				} else {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected =",str,p));
				}
				break;
			case 7:
				switch(c) {
				case 34:case 39:
					buf = new StringBuf();
					state = 8;
					start = p + 1;
					attrValQuote = c;
					break;
				default:
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected \"",str,p));
				}
				break;
			case 8:
				switch(c) {
				case 38:
					let len = p - start;
					buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
					state = 18;
					escapeNext = 8;
					start = p + 1;
					break;
				case 60:case 62:
					if(strict) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Invalid unescaped " + String.fromCodePoint(c) + " in attribute value",str,p));
					} else if(c == attrValQuote) {
						let len = p - start;
						buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
						let val = buf.b;
						buf = new StringBuf();
						xml.set(aname,val);
						state = 0;
						next = 4;
					}
					break;
				default:
					if(c == attrValQuote) {
						let len = p - start;
						buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
						let val = buf.b;
						buf = new StringBuf();
						xml.set(aname,val);
						state = 0;
						next = 4;
					}
				}
				break;
			case 9:
				p = haxe_xml_Parser.doParse(str,strict,p,xml);
				start = p;
				state = 1;
				break;
			case 10:
				if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
					if(start == p) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
					}
					let v = HxOverrides.substr(str,start,p - start);
					if(parent == null || parent.nodeType != 0) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unexpected </" + v + ">, tag is not open",str,p));
					}
					if(parent.nodeType != Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
					}
					if(v != parent.nodeName) {
						if(parent.nodeType != Xml.Element) {
							throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
						}
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected </" + parent.nodeName + ">",str,p));
					}
					state = 0;
					next = 12;
					continue;
				}
				break;
			case 11:
				if(c == 62) {
					state = 1;
				} else {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected >",str,p));
				}
				break;
			case 12:
				if(c == 62) {
					if(nsubs == 0) {
						parent.addChild(Xml.createPCData(""));
					}
					return p;
				} else {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected >",str,p));
				}
				break;
			case 13:
				if(c == 60) {
					let len = p - start;
					buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
					let child = Xml.createPCData(buf.b);
					buf = new StringBuf();
					parent.addChild(child);
					++nsubs;
					state = 0;
					next = 2;
				} else if(c == 38) {
					let len = p - start;
					buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
					state = 18;
					escapeNext = 13;
					start = p + 1;
				}
				break;
			case 14:
				if(c == 63 && str.charCodeAt(p + 1) == 62) {
					++p;
					let str1 = HxOverrides.substr(str,start + 1,p - start - 2);
					parent.addChild(Xml.createProcessingInstruction(str1));
					++nsubs;
					state = 1;
				}
				break;
			case 15:
				if(c == 45 && str.charCodeAt(p + 1) == 45 && str.charCodeAt(p + 2) == 62) {
					parent.addChild(Xml.createComment(HxOverrides.substr(str,start,p - start)));
					++nsubs;
					p += 2;
					state = 1;
				}
				break;
			case 16:
				if(c == 91) {
					++nbrackets;
				} else if(c == 93) {
					--nbrackets;
				} else if(c == 62 && nbrackets == 0) {
					parent.addChild(Xml.createDocType(HxOverrides.substr(str,start,p - start)));
					++nsubs;
					state = 1;
				}
				break;
			case 17:
				if(c == 93 && str.charCodeAt(p + 1) == 93 && str.charCodeAt(p + 2) == 62) {
					let child = Xml.createCData(HxOverrides.substr(str,start,p - start));
					parent.addChild(child);
					++nsubs;
					p += 2;
					state = 1;
				}
				break;
			case 18:
				if(c == 59) {
					let s = HxOverrides.substr(str,start,p - start);
					if(s.charCodeAt(0) == 35) {
						let c = s.charCodeAt(1) == 120 ? Std.parseInt("0" + HxOverrides.substr(s,1,s.length - 1)) : Std.parseInt(HxOverrides.substr(s,1,s.length - 1));
						buf.b += String.fromCodePoint(c);
					} else if(!Object.prototype.hasOwnProperty.call(haxe_xml_Parser.escapes.h,s)) {
						if(strict) {
							throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Undefined entity: " + s,str,p));
						}
						buf.b += Std.string("&" + s + ";");
					} else {
						buf.b += Std.string(haxe_xml_Parser.escapes.h[s]);
					}
					start = p + 1;
					state = escapeNext;
				} else if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45) && c != 35) {
					if(strict) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Invalid character in entity: " + String.fromCodePoint(c),str,p));
					}
					buf.b += String.fromCodePoint(38);
					let len = p - start;
					buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
					--p;
					start = p + 1;
					state = escapeNext;
				}
				break;
			}
			++p;
		}
		if(state == 1) {
			start = p;
			state = 13;
		}
		if(state == 13) {
			if(parent.nodeType == 0) {
				if(parent.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
				}
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unclosed node <" + parent.nodeName + ">",str,p));
			}
			if(p != start || nsubs == 0) {
				let len = p - start;
				buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
				parent.addChild(Xml.createPCData(buf.b));
				++nsubs;
			}
			return p;
		}
		if(!strict && state == 18 && escapeNext == 13) {
			buf.b += String.fromCodePoint(38);
			let len = p - start;
			buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
			parent.addChild(Xml.createPCData(buf.b));
			++nsubs;
			return p;
		}
		throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unexpected end",str,p));
	}
}
$hxClasses["haxe.xml.Parser"] = haxe_xml_Parser;
haxe_xml_Parser.__name__ = "haxe.xml.Parser";
class haxe_xml_Printer {
	constructor(pretty) {
		this.output = new StringBuf();
		this.pretty = pretty;
	}
	writeNode(value,tabs) {
		switch(value.nodeType) {
		case 0:
			this.output.b += Std.string(tabs + "<");
			if(value.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string(value.nodeName);
			let attribute = value.attributes();
			while(attribute.hasNext()) {
				let attribute1 = attribute.next();
				this.output.b += Std.string(" " + attribute1 + "=\"");
				let input = StringTools.htmlEscape(value.get(attribute1),true);
				this.output.b += Std.string(input);
				this.output.b += "\"";
			}
			if(this.hasChildren(value)) {
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
				if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
				}
				let _g_current = 0;
				let _g_array = value.children;
				while(_g_current < _g_array.length) {
					let child = _g_array[_g_current++];
					this.writeNode(child,this.pretty ? tabs + "\t" : tabs);
				}
				this.output.b += Std.string(tabs + "</");
				if(value.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
				}
				this.output.b += Std.string(value.nodeName);
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
			} else {
				this.output.b += "/>";
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 1:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			let nodeValue = value.nodeValue;
			if(nodeValue.length != 0) {
				let input = tabs + StringTools.htmlEscape(nodeValue);
				this.output.b += Std.string(input);
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 2:
			this.output.b += Std.string(tabs + "<![CDATA[");
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string(value.nodeValue);
			this.output.b += "]]>";
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 3:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			let commentContent = value.nodeValue;
			let _this_r = new RegExp("[\n\r\t]+","g".split("u").join(""));
			commentContent = commentContent.replace(_this_r,"");
			commentContent = "<!--" + commentContent + "-->";
			this.output.b += tabs == null ? "null" : "" + tabs;
			let input = StringTools.trim(commentContent);
			this.output.b += Std.string(input);
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 4:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string("<!DOCTYPE " + value.nodeValue + ">");
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 5:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string("<?" + value.nodeValue + "?>");
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 6:
			if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			let _g_current = 0;
			let _g_array = value.children;
			while(_g_current < _g_array.length) {
				let child = _g_array[_g_current++];
				this.writeNode(child,tabs);
			}
			break;
		}
	}
	hasChildren(value) {
		if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
		}
		let _g_current = 0;
		let _g_array = value.children;
		while(_g_current < _g_array.length) {
			let child = _g_array[_g_current++];
			switch(child.nodeType) {
			case 0:case 1:
				return true;
			case 2:case 3:
				if(child.nodeType == Xml.Document || child.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (child.nodeType == null ? "null" : XmlType.toString(child.nodeType)));
				}
				if(StringTools.ltrim(child.nodeValue).length != 0) {
					return true;
				}
				break;
			default:
			}
		}
		return false;
	}
	static print(xml,pretty) {
		if(pretty == null) {
			pretty = false;
		}
		let printer = new haxe_xml_Printer(pretty);
		printer.writeNode(xml,"");
		return printer.output.b;
	}
}
$hxClasses["haxe.xml.Printer"] = haxe_xml_Printer;
haxe_xml_Printer.__name__ = "haxe.xml.Printer";
Object.assign(haxe_xml_Printer.prototype, {
	__class__: haxe_xml_Printer
});
class js_Boot {
	static getClass(o) {
		if(o == null) {
			return null;
		} else if(((o) instanceof Array)) {
			return Array;
		} else {
			let cl = o.__class__;
			if(cl != null) {
				return cl;
			}
			let name = js_Boot.__nativeClassName(o);
			if(name != null) {
				return js_Boot.__resolveNativeClass(name);
			}
			return null;
		}
	}
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(o.__enum__) {
				let e = $hxEnums[o.__enum__];
				let con = e.__constructs__[o._hx_index];
				let n = con._hx_name;
				if(con.__params__) {
					s = s + "\t";
					return n + "(" + ((function($this) {
						var $r;
						let _g = [];
						{
							let _g1 = 0;
							let _g2 = con.__params__;
							while(true) {
								if(!(_g1 < _g2.length)) {
									break;
								}
								let p = _g2[_g1];
								_g1 = _g1 + 1;
								_g.push(js_Boot.__string_rec(o[p],s));
							}
						}
						$r = _g;
						return $r;
					}(this))).join(",") + ")";
				} else {
					return n;
				}
			}
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
	static __nativeClassName(o) {
		let name = js_Boot.__toStr.call(o).slice(8,-1);
		if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
			return null;
		}
		return name;
	}
	static __resolveNativeClass(name) {
		return $global[name];
	}
}
js_Boot.__toStr = null;
$hxClasses["js.Boot"] = js_Boot;
js_Boot.__name__ = "js.Boot";
class js_injecting_InjectContainer {
	constructor(injector) {
		injector.injectInto(this);
	}
}
$hxClasses["js.injecting.InjectContainer"] = js_injecting_InjectContainer;
js_injecting_InjectContainer.__name__ = "js.injecting.InjectContainer";
Object.assign(js_injecting_InjectContainer.prototype, {
	__class__: js_injecting_InjectContainer
});
class js_injecting_InjectorRO {
}
$hxClasses["js.injecting.InjectorRO"] = js_injecting_InjectorRO;
js_injecting_InjectorRO.__name__ = "js.injecting.InjectorRO";
Object.assign(js_injecting_InjectorRO.prototype, {
	__class__: js_injecting_InjectorRO
});
class js_injecting_Injector {
	constructor() {
		this.instances = new Map();
		this.singletons = new Map();
		this.allowNoRttiForClasses = new Set();
	}
	addSingletonSimple(type) {
		if(type == null) {
			throw new Error("Argument `type` must not be null.");
		}
		let rtti = haxe_rtti_Rtti.getRtti(type);
		if(rtti.isInterface) {
			throw new Error("Interface must be mapped. Use class instead or injector's method with mapping.");
		}
		this.singletons.set(rtti.path,{ mapTo : rtti.path, value : null});
		return this;
	}
	addSingletonMappedToClass(type,mapTo) {
		if(type == null) {
			throw new Error("Argument `type` must not be null.");
		}
		if(mapTo == null) {
			throw new Error("Argument `mapTo` must not be null.");
		}
		let rtti2 = haxe_rtti_Rtti.getRtti(mapTo);
		if(rtti2.isInterface) {
			throw new Error("Could't map to interface.");
		}
		this.singletons.set(haxe_rtti_Rtti.getRtti(type).path,{ mapTo : rtti2.path, value : null});
		return this;
	}
	addSingletonMappedToValue(type,value) {
		if(type == null) {
			throw new Error("Argument `type` must not be null.");
		}
		if(value == null) {
			throw new Error("Argument `value` must not be null.");
		}
		let rtti = haxe_rtti_Rtti.getRtti(type);
		this.singletons.set(rtti.path,{ mapTo : rtti.path, value : value});
		return this;
	}
	addInstanceSimple(type) {
		if(type == null) {
			throw new Error("Argument `type` must not be null.");
		}
		let rtti = haxe_rtti_Rtti.getRtti(type);
		if(rtti.isInterface) {
			throw new Error("Interface must be mapped. Use class instead or injector's method with mapping.");
		}
		this.instances.set(rtti.path,rtti.path);
		return this;
	}
	addInstanceMappedToClass(type,mapTo) {
		if(type == null) {
			throw new Error("Argument `type` must not be null.");
		}
		if(mapTo == null) {
			throw new Error("Argument `mapTo` must not be null.");
		}
		let rtti2 = haxe_rtti_Rtti.getRtti(mapTo);
		if(rtti2.isInterface) {
			throw new Error("Could't map to interface.");
		}
		this.instances.set(haxe_rtti_Rtti.getRtti(type).path,rtti2.path);
		return this;
	}
	injectInto(target) {
		this.injectIntoInner(target,js_Boot.getClass(target));
	}
	getService(type) {
		let name = haxe_rtti_Rtti.getRtti(type).path;
		return this.getObject(name);
	}
	allowNoRttiForClass(type) {
		this.allowNoRttiForClasses.add(type);
	}
	injectIntoInner(target,type) {
		if(type == null) {
			throw new Error("Inject target must have reference to class in `__proto__.__class__` property.");
		}
		if(this.allowNoRttiForClasses.has(type) && !haxe_rtti_Rtti.hasRtti(type)) {
			return;
		}
		let rtti = haxe_rtti_Rtti.getRtti(type);
		let _g = 0;
		let _g1 = rtti.fields;
		while(_g < _g1.length) {
			let field = _g1[_g];
			++_g;
			if(Lambda.exists(field.meta,function(m) {
				return m.name == "inject";
			})) {
				let _g = field.type;
				if(_g._hx_index == 2) {
					let name = _g.name;
					let paramsList = _g.params;
					if(!target[field.name]) {
						let obj = this.getObject(name);
						if(obj == null) {
							throw new Error("Type '" + name + "' not found in injector.");
						}
						target[field.name] = obj;
					}
				} else {
					throw new Error("Only classes are supported.");
				}
			}
		}
		if(rtti.superClass != null) {
			this.injectIntoInner(target,type.__super__);
		}
	}
	getObject(name) {
		let data = this.singletons.get(name);
		if((data != null ? data.value : null) != null) {
			return data.value;
		}
		if(data != null) {
			data.value = this.createObject(data.mapTo);
			return data.value;
		}
		return this.createObject(this.instances.get(name));
	}
	createObject(mapToName) {
		let type = $hxClasses[mapToName];
		if(type == null) {
			return null;
		}
		let r = Type.createInstance(type,[this]);
		if(!((r) instanceof js_injecting_InjectContainer)) {
			this.injectInto(r);
		}
		return r;
	}
}
$hxClasses["js.injecting.Injector"] = js_injecting_Injector;
js_injecting_Injector.__name__ = "js.injecting.Injector";
Object.assign(js_injecting_Injector.prototype, {
	__class__: js_injecting_Injector
});
class mypack_MyInstance {
	constructor() {
		console.log("test/src/mypack/MyInstance.hx:8:","MyInstance.new");
	}
}
$hxClasses["mypack.MyInstance"] = mypack_MyInstance;
mypack_MyInstance.__name__ = "mypack.MyInstance";
Object.assign(mypack_MyInstance.prototype, {
	__class__: mypack_MyInstance
});
class mypack_MyService extends js_injecting_InjectContainer {
	constructor(injector) {
		super(injector);
		console.log("test/src/mypack/MyService.hx:14:","MyService.new: " + (this.a != null ? "`a` defined" : "`a` NOT DEFINED"));
	}
}
$hxClasses["mypack.MyService"] = mypack_MyService;
mypack_MyService.__name__ = "mypack.MyService";
mypack_MyService.__super__ = js_injecting_InjectContainer;
Object.assign(mypack_MyService.prototype, {
	__class__: mypack_MyService
});
class mypack_MyService2 {
	constructor(t) {
		console.log("test/src/mypack/MyService2.hx:8:","MyService2.new: " + (t == null ? "null" : "" + t));
	}
}
$hxClasses["mypack.MyService2"] = mypack_MyService2;
mypack_MyService2.__name__ = "mypack.MyService2";
Object.assign(mypack_MyService2.prototype, {
	__class__: mypack_MyService2
});
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
$hxClasses["Math"] = Math;
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
{
	Object.defineProperty(String.prototype,"__class__",{ value : $hxClasses["String"] = String, enumerable : false, writable : true});
	String.__name__ = "String";
	$hxClasses["Array"] = Array;
	Array.__name__ = "Array";
}
js_Boot.__toStr = ({ }).toString;
Xml.Element = 0;
Xml.PCData = 1;
Xml.CData = 2;
Xml.Comment = 3;
Xml.DocType = 4;
Xml.ProcessingInstruction = 5;
Xml.Document = 6;
haxe_xml_Parser.escapes = (function($this) {
	var $r;
	let h = new haxe_ds_StringMap();
	h.h["lt"] = "<";
	h.h["gt"] = ">";
	h.h["amp"] = "&";
	h.h["quot"] = "\"";
	h.h["apos"] = "'";
	$r = h;
	return $r;
}(this));
js_injecting_InjectContainer.__rtti = "<class path=\"js.injecting.InjectContainer\" params=\"\">\n\t<new public=\"1\" set=\"method\" line=\"7\"><f a=\"injector\">\n\t<c path=\"js.injecting.InjectorRO\"/>\n\t<x path=\"Void\"/>\n</f></new>\n\t<meta>\n\t\t<m n=\":directlyUsed\"/>\n\t\t<m n=\":rtti\"/>\n\t</meta>\n</class>";
mypack_MyInstance.__rtti = "<class path=\"mypack.MyInstance\" params=\"\">\n\t<new public=\"1\" set=\"method\" line=\"7\"><f a=\"\"><x path=\"Void\"/></f></new>\n\t<meta>\n\t\t<m n=\":directlyUsed\"/>\n\t\t<m n=\":rtti\"/>\n\t</meta>\n</class>";
mypack_MyService.__meta__ = { fields : { a : { inject : null}}};
mypack_MyService.__rtti = "<class path=\"mypack.MyService\" params=\"\">\n\t<extends path=\"js.injecting.InjectContainer\"/>\n\t<a>\n\t\t<c path=\"mypack.MyInstance\"/>\n\t\t<meta><m n=\"inject\"/></meta>\n\t</a>\n\t<new public=\"1\" set=\"method\" line=\"11\"><f a=\"injector\">\n\t<c path=\"js.injecting.InjectorRO\"/>\n\t<x path=\"Void\"/>\n</f></new>\n\t<meta><m n=\":directlyUsed\"/></meta>\n</class>";
mypack_MyService2.__rtti = "<class path=\"mypack.MyService2\" params=\"\">\n\t<new public=\"1\" set=\"method\" line=\"7\"><f a=\"t\">\n\t<x path=\"Bool\"/>\n\t<x path=\"Void\"/>\n</f></new>\n\t<meta>\n\t\t<m n=\":directlyUsed\"/>\n\t\t<m n=\":rtti\"/>\n\t</meta>\n</class>";
Main.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
